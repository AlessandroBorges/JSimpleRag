package bor.tools.simplerag.entity;

import org.hibernate.annotations.Type;

import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import bor.tools.simplerag.entity.enums.TipoEmbedding;
import io.hypersistence.utils.hibernate.type.json.JsonType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.ToString;
import lombok.experimental.SuperBuilder;

/**
 * Entity representing document embeddings for search. (document, chapter, or chunk level).<br>
 * It can reference documents, chapters, or text chunks.<br>
 * Maps to the 'doc_embedding' table in PostgreSQL.
 *
 * Note: This entity uses Spring JDBC for vector operations due to PGVector requirements.
 * JPA is used for basic CRUD and relationships, while vector operations use native queries.
 */
@Entity
@Table(name = "doc_embedding")
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(onlyExplicitlyIncluded = true, callSuper = false)
@JsonPropertyOrder({ "id", "libraryId", "documentoId", "chapterId", "orderChapter", "tipoEmbedding", "metadados" })
public class DocumentEmbedding extends Updatable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    private Integer id;

    /**
     * ID of the library this embedding belongs to (foreign key).
     */
    @Column(name = "library_id", nullable = false)
    private Integer libraryId;

    /**
     * ID of the document this embedding belongs to (foreign key).
     */
    @Column(name = "documento_id", nullable = false)
    private Integer documentoId;

    /**
     * ID of the chapter this embedding belongs to (foreign key).<br>
     * Nullable for document-level embeddings.
     */
    @Column(name = "chapter_id", nullable = true)
    private Integer chapterId;
    
    /**
     * Order of the chunk within the chapter.<br>
     * Nullable for document-level and chapter-level embeddings.
     */
    @Column(name = "order_chapter")
    private Integer orderChapter;

    /**
     * Type of embedding: DOCUMENT, CHAPTER, CHUNK, etc.
     * @see bor.tools.simplerag.entity.enums.TipoEmbedding
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_embedding", nullable = false, length = 50)
    private TipoEmbedding tipoEmbedding;

    /**
     * Text content of the embedding (document, chapter, or chunk text).
     * Stored as TEXT in PostgreSQL to handle large content.
     */	
    @Column(name = "texto", columnDefinition = "TEXT")
    @ToString.Exclude // Avoid printing large content in toString
    private String texto;
    
    /**
     * Full-text search vector for texto, automatically generated by PostgreSQL DDL trigger.<br>
     * This field is read-only and populated by database triggers.<br>
     * DDL:<br>
     * <pre>
     * text_search_tsv tsvector GENERATED ALWAYS AS (
	    setweight(to_tsvector('portuguese', COALESCE(metadados->>'nome', '')), 'A') ||         -- Título ou nome da obra
	    setweight(to_tsvector('portuguese', COALESCE(metadados->>'capitulo', '')), 'A') ||     -- Nome do capítulo
	    setweight(to_tsvector('portuguese', COALESCE(metadados->>'descricao', '')), 'B') ||    -- Descrição geral
	    setweight(to_tsvector('portuguese', COALESCE(metadados->>'area_conhecimento', '')), 'C') || -- Área temática
	    setweight(to_tsvector('portuguese', COALESCE(metadados->>'palavras_chave', '')), 'C') ||   -- Palavras-chave
	    setweight(to_tsvector('portuguese', COALESCE(metadados->>'autor', '')), 'D') ||        -- Autor (menos relevante para conteúdo)
	    setweight(to_tsvector('portuguese', COALESCE(metadados->>'metadados', '')), 'D') ||    -- Outros metadados
	    setweight(to_tsvector('portuguese', COALESCE(texto, '')), 'C')                         -- Texto completo do chunk
	) stored,
	<>/pre>
     * 
     * <h2>Notes:</h2>
     *   <li>This field is managed by the database and should not be set manually.
     *   <li>For full-text search, use native queries or Spring Data JPA @Query annotations.
     *   <li> do not put this field in toString, equals, or hashCode to avoid performance issues.
     *   <li> neither make it available in JSON serialization or DTOs.
     *   
     */
    @Column(name = "text_search_tsv", columnDefinition = "tsvector", insertable = false, updatable = false)
    @ToString.Exclude
    private Object text_search_tsv;
   

    /**
     * Vector embedding stored as float array.
     * Note: For vector operations, use DocEmbeddingJdbcRepository
     * This field is mapped but vector operations require native SQL.
     * 
     * DDL:
     * <pre>
     * embedding vector NULL,      -- Vetor de embeddings   
     * </pre>
     * <h2>Notes:</h2>
     * <ul>
     *  <li> This field is managed by the application and should be set when creating or updating embeddings.
     *  <li> For vector operations, use native queries or Spring JDBC.
     *  <li> do not put this field in toString, equals, or hashCode to avoid performance issues.
     *  <li> It can made available in JSON serialization or DTOs if needed.
     *  <li> The dimension of the vector is not fixed in the entity, but should be consistent with the embedding model used.
     *  <li> Not sure if the best Java type should be float[] or com.pgvector.PgVector or Object, test performance and usability.
     * </ul>
     *  
     */
    @Column(name = "embedding_vector", columnDefinition = "vector(768)") //dimensão fixa de 768, ajustar conforme o modelo de embedding usado
    @ToString.Exclude
    private float[] embeddingVector;

    /**
     * metadata
     */
    @Type(JsonType.class)
    @Column(columnDefinition = "jsonb")
    private MetaDoc metadados;

    /**
     * 
     * @return
     */
    public MetaDoc getMetadados() {
	if (metadados == null) {
	    metadados = new MetaDoc();	 
	}
	return metadados;    
    }
	
    /**
     * Validates the consistency constraints based on tipo_embedding
     */
    @PrePersist
    @PreUpdate
    private void validateConsistency() {
	switch (tipoEmbedding) {
	case RESUMO:
	case DOCUMENTO:
	    if (chapterId != null || orderChapter != null)
		throw new IllegalStateException("Embedding de documento não deve ter capítulo ou ordem");
	    break;
	case CAPITULO:
	    if (chapterId == null || orderChapter != null)
		throw new IllegalStateException("Embedding de capítulo deve ter capítulo, mas não ordem");
	    break;
	case TRECHO:
	    if (chapterId == null || orderChapter == null)
		throw new IllegalStateException("Embedding de trecho deve ter capítulo e ordem");
	    break;
	    
	case METADADOS:
	    break;
	    
	case OUTROS:
	    break;
	    
	case PERGUNTAS_RESPOSTAS:
	    break;
	default:
	    break;

	}
    }

    /**
     * Check if this embedding has a vector
     */
    public boolean hasVector() {
        return embeddingVector != null && embeddingVector.length > 0;
    }

    /**
     * Get vector dimension
     */
    public int getVectorDimension() {
        return embeddingVector != null ? embeddingVector.length : 0;
    }
}