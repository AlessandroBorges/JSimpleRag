package bor.tools.simplerag.entity;

import bor.tools.simplerag.entity.enums.TipoEmbedding;
import io.hypersistence.utils.hibernate.type.json.JsonType;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.Type;

import java.time.LocalDateTime;
import java.util.Map;

/**
 * Entity representing document embeddings for search. (document, chapter, or chunk level).<br>
 * It can reference documents, chapters, or text chunks.<br>
 * Maps to the 'doc_embedding' table in PostgreSQL.
 *
 * Note: This entity uses Spring JDBC for vector operations due to PGVector requirements.
 * JPA is used for basic CRUD and relationships, while vector operations use native queries.
 */
@Entity
@Table(name = "doc_embedding")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class DocumentEmbedding extends Updatable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    private Integer id;

    @Column(name = "libray_id", nullable = false)
    private Integer libraryId;

    @Column(name = "documento_id", nullable = false)
    private Integer documentoId;

    @Column(name = "chapter_id", nullable = true)
    private Integer chapterId;

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_embedding", nullable = false)
    private TipoEmbedding tipoEmbedding;

    @Column(name = "trecho_texto", columnDefinition = "TEXT")
    @ToString.Exclude // Avoid printing large content in toString
    private String trechoTexto;

    @Column(name = "order_chapter")
    private Integer orderChapter;

    /**
     * Vector embedding stored as float array.
     * Note: For vector operations, use DocEmbeddingJdbcRepository
     * This field is mapped but vector operations require native SQL.
     */
    @Column(name = "embedding_vector", columnDefinition = "vector(1536)") // Default dimension for text-embedding-ada-002
    @ToString.Exclude
    private float[] embeddingVector;

    /**
     * Full-text search vector automatically generated by PostgreSQL trigger.
     * This field is read-only and populated by database triggers.
     */
    @Column(name = "texto_indexado", columnDefinition = "tsvector", insertable = false, updatable = false)
    @ToString.Exclude
    private String textoIndexado;

    @Type(JsonType.class)
    @Column(columnDefinition = "jsonb")
    private Map<String, Object> metadados;

    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;


    /**
     * Validates the consistency constraints based on tipo_embedding
     */
    @PrePersist
    @PreUpdate
    private void validateConsistency() {
	switch (tipoEmbedding) {
	case RESUMO:
	case DOCUMENTO:
	    if (chapterId != null || orderChapter != null)
		throw new IllegalStateException("Embedding de documento não deve ter capítulo ou ordem");
	    break;
	case CAPITULO:
	    if (chapterId == null || orderChapter != null)
		throw new IllegalStateException("Embedding de capítulo deve ter capítulo, mas não ordem");
	    break;
	case TRECHO:
	    if (chapterId == null || orderChapter == null)
		throw new IllegalStateException("Embedding de trecho deve ter capítulo e ordem");
	    break;
	    
	case METADADOS:
	    break;
	    
	case OUTROS:
	    break;
	    
	case PERGUNTAS_RESPOSTAS:
	    break;
	default:
	    break;

	}
    }

    /**
     * Check if this embedding has a vector
     */
    public boolean hasVector() {
        return embeddingVector != null && embeddingVector.length > 0;
    }

    /**
     * Get vector dimension
     */
    public int getVectorDimension() {
        return embeddingVector != null ? embeddingVector.length : 0;
    }
}